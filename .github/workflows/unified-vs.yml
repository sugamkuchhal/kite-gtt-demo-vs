name: Unified Script Runner VS

on:
  schedule:
    - cron: "0,30 4-9 * * 1-5"  # 09:30–15:00 IST every 30 mins, Mon–Fri (midday)
    - cron: "30 11 * * 1-5"     # 17:00 IST (EOD), Mon–Fri
  workflow_dispatch:
    inputs:
      command:
        description: "Optional: full command to run (e.g. python3 fetch_holdings_vs.py). Leave empty to run the automated chain."
        required: false
        default: ""
      run_type:
        description: "Optional: choose which chain to run when no command is provided."
        required: false
        type: choice
        options: [auto, midday, eod]
        default: auto

concurrency:
  group: unified-script-runner-vs
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # === PRE (no Chrome yet) =================================================
      - name: Set timezone (IST)
        run: echo "TZ=Asia/Kolkata" >> "$GITHUB_ENV"

      - name: Set up Python (with pip cache)
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Create virtualenv & minimal deps (preflight only)
        shell: bash
        run: |
          python -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip
          pip install kiteconnect requests

      # api_key_vs.txt must be the 5-line file your login script expects
      - name: Recreate essential secret files in $RUNNER_TEMP and symlink into CWD
        shell: bash
        env:
          API_KEY_VS: ${{ secrets.API_KEY_VS }}       # 5 lines: api_key, api_secret, user_id, password, totp_seed
          ACCESS_TOKEN_VS: ${{ secrets.ACCESS_TOKEN_VS }}
          CREDS_VS_JSON: ${{ secrets.CREDS_VS_JSON }}
        run: |
          set -euo pipefail
          tmp="$RUNNER_TEMP"
          mkdir -p "$tmp"

          if [[ -z "${API_KEY_VS:-}" ]]; then
            echo "::error::Secret API_KEY_VS is empty. It must contain 5 lines: api_key, api_secret, user_id, password, totp_seed."
            exit 1
          fi
          printf '%s' "$API_KEY_VS" > "$tmp/api_key_vs.txt"

          if [[ -n "${ACCESS_TOKEN_VS:-}" ]]; then
            printf '%s' "$ACCESS_TOKEN_VS" > "$tmp/access_token_vs.txt"
          fi
          if [[ -n "${CREDS_VS_JSON:-}" ]]; then
            printf '%s' "$CREDS_VS_JSON" > "$tmp/creds_vs.json"
          fi

          ln -sf "$tmp/api_key_vs.txt" ./api_key_vs.txt
          [[ -f "$tmp/access_token_vs.txt" ]] && ln -sf "$tmp/access_token_vs.txt" ./access_token_vs.txt || true
          [[ -f "$tmp/creds_vs.json" ]]       && ln -sf "$tmp/creds_vs.json"       ./creds_vs.json       || true

      - name: Auth preflight (Kite) -> sets auth_status: ok|refresh
        id: preflight
        shell: bash
        run: |
          set -euo pipefail
          source .venv/bin/activate

          if [[ $(wc -l < api_key_vs.txt) -lt 5 ]]; then
            echo "::error::api_key_vs.txt does not have 5 lines (api_key, api_secret, user_id, password, totp_seed)."
            exit 1
          fi

          STATUS="refresh"
          if [[ -s "./access_token_vs.txt" ]]; then
            python - <<'PY' || exit 2
from kiteconnect import KiteConnect
lines = [l.strip() for l in open("api_key_vs.txt").read().splitlines()]
api_key = lines[0]
token   = open("access_token_vs.txt").read().strip()
kite = KiteConnect(api_key=api_key)
kite.set_access_token(token)
kite.margins()  # raises if invalid/expired
PY
            [[ $? -eq 0 ]] && STATUS="ok"
          fi

          echo "auth_status=${STATUS}" >> "$GITHUB_OUTPUT"
          echo "::notice::Kite auth preflight: ${STATUS}"

      # === IF REFRESH NEEDED → JIT Chrome & headless login =====================
      - name: Setup Chrome (JIT)
        if: ${{ steps.preflight.outputs.auth_status == 'refresh' }}
        uses: browser-actions/setup-chrome@v1
        with:
          chrome-version: stable

      - name: Export CHROME_BINARY & headless flags (for auto_login_vs.py)
        if: ${{ steps.preflight.outputs.auth_status == 'refresh' }}
        shell: bash
        run: |
          echo "CHROME_BINARY=$(command -v google-chrome || command -v google-chrome-stable || command -v chromium || command -v chromium-browser)" >> "$GITHUB_ENV"
          echo "HEADLESS=1" >> "$GITHUB_ENV"
          echo "CI=true" >> "$GITHUB_ENV"

      - name: Install automation deps (only for refresh path)
        if: ${{ steps.preflight.outputs.auth_status == 'refresh' }}
        shell: bash
        run: |
          source .venv/bin/activate
          pip install selenium pyotp webdriver-manager

      - name: Refresh token via headless login (auto_login_vs.py)
        if: ${{ steps.preflight.outputs.auth_status == 'refresh' }}
        shell: bash
        run: |
          set -euo pipefail
          source .venv/bin/activate
          python3 auto_login_vs.py
          if [[ ! -s "./access_token_vs.txt" ]]; then
            echo "::error::Token file missing after login."
            exit 1
          fi
          cp ./access_token_vs.txt "$RUNNER_TEMP/access_token_vs.txt"
          rm -f ./access_token_vs.txt
          ln -sf "$RUNNER_TEMP/access_token_vs.txt" ./access_token_vs.txt

      - name: Verify refreshed token -> sets auth_status_final
        if: ${{ steps.preflight.outputs.auth_status == 'refresh' }}
        id: postcheck
        shell: bash
        run: |
          set -euo pipefail
          source .venv/bin/activate
          python - <<'PY'
from kiteconnect import KiteConnect
lines = [l.strip() for l in open("api_key_vs.txt").read().splitlines()]
api_key = lines[0]
token   = open("access_token_vs.txt").read().strip()
kite = KiteConnect(api_key=api_key)
kite.set_access_token(token)
kite.margins()
PY
          echo "auth_status_final=ok" >> "$GITHUB_OUTPUT"

      # === POST (only proceed if auth is OK) ===================================
      - name: Compute auth gate
        id: authgate
        shell: bash
        run: |
          if [[ "${{ steps.preflight.outputs.auth_status }}" == "ok" ]]; then
            echo "status=ok" >> "$GITHUB_OUTPUT"
          elif [[ "${{ steps.postcheck.outputs.auth_status_final || '' }}" == "ok" ]]; then
            echo "status=ok" >> "$GITHUB_OUTPUT"
          else
            echo "status=fail" >> "$GITHUB_OUTPUT"
          fi

      - name: Ensure auth is OK before running chains
        if: ${{ steps.authgate.outputs.status == 'fail' }}
        shell: bash
        run: |
          echo "::error::Authentication not available. Aborting trading chain."
          exit 1

      - name: Install full project deps
        shell: bash
        run: |
          source .venv/bin/activate
          pip install \
            gspread gspread-formatting kiteconnect pandas requests \
            retrying tqdm google-auth google-auth-oauthlib google-auth-httplib2 \
            selenium pyotp yfinance oauth2client google-api-python-client

      - name: Run (manual command if provided, else choose auto/midday/eod)
        env:
          INPUT_COMMAND: ${{ github.event.inputs.command }}
          RUN_TYPE: ${{ github.event.inputs.run_type }}
        shell: bash
        run: |
          set -euo pipefail
          source .venv/bin/activate

          # 1) Manual command overrides everything
          if [[ -n "${INPUT_COMMAND:-}" ]]; then
            echo "::notice::Running manual command: ${INPUT_COMMAND}"
            eval "${INPUT_COMMAND}"
            exit 0
          fi

          # 2) Normalize run_type (default auto)
          RT="${RUN_TYPE:-auto}"

          # Helper: convert HH:MM to minutes since midnight
          hm_to_min() {
            IFS=: read -r h m <<<"$1"
            echo $((10#$h*60 + 10#$m))
          }

          # 3) Auto decision window → 09:00–15:45 IST (inclusive)
          NOW_HM="$(date +%H:%M)"
          NOW_MIN="$(hm_to_min "$NOW_HM")"
          MID_START="$(hm_to_min "09:00")"
          MID_END="$(hm_to_min "15:45")"
          IN_MIDDAY=false
          if [[ $NOW_MIN -ge $MID_START && $NOW_MIN -le $MID_END ]]; then
            IN_MIDDAY=true
          fi

          # 4) Choose which chain to run
          case "$RT" in
            midday)
              echo "::notice::run_type=midday selected"
              RUN_MIDDAY=true
              ;;
            eod)
              echo "::notice::run_type=eod selected"
              RUN_MIDDAY=false
              ;;
            auto|*)
              echo "::notice::run_type=auto; current IST time is $NOW_HM"
              if [[ "$IN_MIDDAY" == true ]]; then
                RUN_MIDDAY=true
              else
                RUN_MIDDAY=false
              fi
              ;;
          esac

          # 5) Execute the chosen chain
          if [[ "$RUN_MIDDAY" == true ]]; then
            echo "::group::RUN: Mid-day chain (VS)"
            python3 set_field_false_vs.py
            python3 fetch_all_gtts_vs.py
            python3 fetch_all_orders_vs.py
            python3 gtt_processor_vs.py --sheet-id "145TqrpQ3Twx6Tezh28s5GnbowlBb_qcY5UM1RvfIclI" --sheet-name "DEL_GTT_INS"
            python3 gtt_processor_vs.py --sheet-id "145TqrpQ3Twx6Tezh28s5GnbowlBb_qcY5UM1RvfIclI" --sheet-name "INS_GTT_INS"
            python3 gtt_processor_vs.py --sheet-id "145TqrpQ3Twx6Tezh28s5GnbowlBb_qcY5UM1RvfIclI" --sheet-name "GTT_INS"
            echo "::endgroup::"
          else
            echo "::group::RUN: EOD chain (VS)"
            python3 set_field_false_vs.py
            python3 fetch_all_gtts_vs.py
            python3 fetch_all_orders_vs.py
            python3 append_new_orders_vs.py
            python3 fifo_portfolio_vs.py
            python3 fetch_holdings_vs.py
            python3 date_ext_vs.py
            python3 data_val_vs.py
            bash combined_run_vs.sh
            echo "::endgroup::"
          fi
